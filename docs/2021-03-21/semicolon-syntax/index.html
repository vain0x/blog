<!DOCTYPE html>
<html lang="ja" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>プログラミング言語の構文とセミコロン - ベインのブログ</title>
  <meta name="description" content="文の区切りとしてのセミコロンについて、いくつかのプログラミング言語の事例をみていく記事です">
  <meta name="author" content="ベイン"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "ベインのブログ",
    
    "url": "https:\/\/vain0x.github.io\/blog\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/vain0x.github.io\/blog\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/vain0x.github.io\/blog\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/vain0x.github.io\/blog\/2021-03-21\/semicolon-syntax\/",
          "name": "プログラミング言語の構文とセミコロン"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "ベイン"
  },
  "headline": "プログラミング言語の構文とセミコロン",
  "description" : "文の区切りとしてのセミコロンについて、いくつかのプログラミング言語の事例をみていく記事です\n",
  "inLanguage" : "ja",
  "wordCount":  519 ,
  "datePublished" : "2021-03-21T00:00:00",
  "dateModified" : "2021-03-21T00:00:00",
  "image" : "https:\/\/vain0x.github.io\/blog\/",
  "keywords" : [ "言語設計" ],
  "mainEntityOfPage" : "https:\/\/vain0x.github.io\/blog\/2021-03-21\/semicolon-syntax\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/vain0x.github.io\/blog\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/vain0x.github.io\/blog\/",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="プログラミング言語の構文とセミコロン" />
<meta property="og:description" content="文の区切りとしてのセミコロンについて、いくつかのプログラミング言語の事例をみていく記事です">
<meta property="og:url" content="https://vain0x.github.io/blog/2021-03-21/semicolon-syntax/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="ベインのブログ" />

  <meta name="twitter:title" content="プログラミング言語の構文とセミコロン" />
  <meta name="twitter:description" content="文の区切りとしてのセミコロンについて、いくつかのプログラミング言語の事例をみていく記事です">
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@vain0x" />
  <meta name="twitter:creator" content="@vain0x" />
  <link href='https://vain0x.github.io/favicon.jpg' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.111.3">
  <link rel="alternate" href="https://vain0x.github.io/blog/index.xml" type="application/rss+xml" title="ベインのブログ">

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  <link rel="stylesheet" href="https://vain0x.github.io/blog/css/main.css" />
  <link rel="stylesheet" href="https://vain0x.github.io/blog/css/syntax.css" />
  <link rel="stylesheet" href="https://vain0x.github.io/blog/css/codeblock.css" />

<link rel="icon" type="image/png" href="https://vain0x.github.io/favicon.jpg"/>




  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom top-nav-short">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://vain0x.github.io/blog/">ベインのブログ</a>
    </div>

    <div id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="記事一覧" href="/blog/posts">記事一覧</a>
            </li>
          
        
          
            <li>
              <a title="競プロ参戦記" href="https://qiita.com/search?q=%E7%AB%B6%E3%83%97%E3%83%AD%E5%8F%82%E6%88%A6%E8%A8%98&#43;user%3Avain0x&amp;sort=created">競プロ参戦記</a>
            </li>
          
        
          
            <li>
              <a title="ABOUT" href="https://vain0x.github.io">ABOUT</a>
            </li>
          
        
      </ul>
    </div>

    

  </div>
</nav>

    
  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>プログラミング言語の構文とセミコロン</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;2021年3月21日 投稿
  
  
  
  <span class="post-meta-tags">
  <a class="post-meta-tag" href="https://vain0x.github.io/blog/tags/%E8%A8%80%E8%AA%9E%E8%A8%AD%E8%A8%88/">言語設計</a>
  </span>
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <p>文の区切りとしてのセミコロンについて、いくつかのプログラミング言語の事例をみていく記事です</p>
<p>主張や結論があるわけではなく、単に複数のトピックを書いています</p>
<!-- raw HTML omitted -->
<h2 id="c言語のセミコロンと文宣言">C言語のセミコロンと文・宣言</h2>
<p>C言語の構文は「文の末尾にセミコロンが必須」とよく説明されます。基本的にそのとおりですが、次の点についても説明がつくように、まずCの構文定義をみていきます</p>
<ul>
<li><code>int a;</code> や <code>f();</code> のような記述ではセミコロン必須</li>
<li><code>while (1) {}</code> のようにセミコロンがなくてもいいこともある
<ul>
<li>「<code>{}</code> で終わる場合はセミコロンがつかない」という誤解</li>
</ul>
</li>
<li><code>struct S {};</code> のように <code>{}</code> とセミコロンの両方が出てくることもある</li>
</ul>
<p>C言語の構文は主に <strong>式</strong>、<strong>文</strong>、<strong>宣言</strong> の3種類に分かれます</p>
<p>(※関数の本体における構文だけ取り上げます。また、ラベルや属性は本題から外れるので無視します)</p>
<h3 id="文の末尾の記号">文の末尾の記号</h3>
<p>式についてはいうまでもないので説明は省略します。宣言は後回しにします</p>
<p>文から見ていきます。<strong>文の末尾が <code>;</code> か <code>}</code> か</strong> という観点で、文を3種類に分類します:</p>
<ul>
<li>明示的にセミコロンで終わる文</li>
<li>複合文</li>
<li>文で終わる文</li>
</ul>
<p><strong>明示的にセミコロンで終わる文</strong> は文の定義として最後にセミコロンが書かれているものです。例えば式文の定義は <code>expression ;</code> (式の後ろにセミコロン) となっていて、末尾がセミコロンになります。この種の文は、ほかに break, return, do-while などがあります。これらの文は「セミコロン必須」の説明に合致します</p>
<p>次に <strong>複合文</strong> は複数の文 (や宣言) を包んで1つの文とするものです。例えば <code>{ f(); g(); }</code> という記述は、関数呼び出しの式文2つから構成される複合文です。複合文の末尾は、見ての通り <code>}</code> で終わります。複合文が存在するため「文の末尾にセミコロンがつかない」状況が発生するわけです</p>
<blockquote>
<p>複合文の定義: <code>{}</code> の中に文や宣言を0個以上並べたものという意味</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">statement</span> <span class="o">|</span> <span class="n">declaration</span><span class="p">...(</span><span class="n">optional</span><span class="p">)</span> <span class="p">}</span>
</span></span></code></pre></div></blockquote>
<p>最後に上記以外の文を確認します。これらは文の前方にいろいろと足していく構造とみなせます。例えば <code>while</code> 文の定義は次の通り:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span> <span class="n">expression</span> <span class="p">)</span> <span class="n">statement</span>
</span></span></code></pre></div><p>この文の末尾はまた別の何らかの文ですが、「文の末尾にある文」をたどっていくと最終的には末尾が文でないものにたどり着き、それはセミコロンで終わる文か、複合文のどちらかです。そのため、文の末尾は必ず <code>;</code> か <code>}</code> で終わることとなります</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="c1">// 例: 式文の手前にいろいろくっついているが、
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     文全体としてはセミコロンで終わる
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span> <span class="k">else</span> <span class="k">for</span><span class="p">(;;)</span> <span class="k">while</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="nf">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//                               ^~~~
</span></span></span></code></pre></div><h3 id="宣言">宣言</h3>
<p>(※宣言の構文を深堀りすると本題から逸れるので詳しくは書きません……)</p>
<p>宣言は <code>int a;</code> のように変数を宣言する構文であるだけでなく、<code>typedef int i32;</code> や <code>struct S { int x; };</code> のように型を定義する構文でもあります</p>
<p>宣言の末尾は <code>;</code> となります。<code>struct S {…};</code> における <code>{}</code> は前述の複合文とは関係なく、型の記述の一部です。これが「<code>{}</code> とセミコロンの両方が出てくる」ケースに相当します</p>
<p>基本的に、宣言は <code>型 変数, 変数, …;</code> という構造です。ただし「型」や「変数」の部分は単純な型名や変数名にかぎりません。
型の部分に <code>struct S {…}</code> のような構造体の定義を記述することができます。
さらにその場合、変数の部分は省略可能なので、<code>型;</code> だけで宣言として完結します</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="c1">// 型の部分が struct S {…} で、「変数…」の部分が省略された宣言
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div><p>このような「型の定義」もあくまで宣言の一種であるため、変数リストの部分を書くこともできます:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="c1">// 「変数…」の部分が obj (変数名) である宣言
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span> <span class="n">obj</span><span class="p">;</span>
</span></span></code></pre></div><p>つまり、このように <code>struct S {…}</code> の後ろにまだ変数リストが続けられるので、<code>}</code> で終わりという構文になっていないと考えられます</p>
<p>ちなみに型の定義を宣言の構文の一種にするという設計は、C言語に近い見た目のほかの言語でもあまり踏襲されていなさそうです (後述の Go, Rust など)</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://en.cppreference.com/w/c/language/statements">Statements - cppreference.com</a></li>
<li><a href="https://en.cppreference.com/w/c/language/declarations">Declarations - cppreference.com</a></li>
</ul>
<h2 id="javascriptの自動セミコロン挿入">JavaScriptの自動セミコロン挿入</h2>
<p>JavaScriptはJavaに似た構文を持つ言語です (C言語 → Java → JavaScript みたいな系譜)</p>
<p>JavaScriptには自動セミコロン挿入という機能があります (詳細はリンク先を参照)。
平たくいうと行末にはセミコロンを書かなくていいということです</p>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion">字句文法 - JavaScript | MDN #自動セミコロン挿入</a></p>
<p>自動セミコロン挿入に関して、いくつか課題が知られています。1つ目の課題は <code>return</code> の直後に改行を入れると文が区切られるものです。
上記のリンク先にある例を引用します:</p>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 上記の文は、 ASI によって次のように変換されます
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span></span></code></pre></div></blockquote>
<p>上の文は <code>return (a + b);</code> という1つの文のつもりで書かれているかもしれませんが、実際には <code>return;</code> と <code>a + b;</code> という2つの文に解釈されます (これは意図しない挙動かもしれない)</p>
<p>あくまで筆者の感覚でいえば、この問題が実際にトラブルになることは少ないと思います。
このケースでは <code>return;</code> 文の後ろにある <code>a + b;</code> の文は絶対に実行されないので、エディタの機能や、リンター (プログラムの誤りを指摘するツール) があれば、警告を受けます。TypeScript を使って型検査をしていれば、関数の返り値の型が <code>void</code> (返り値なし) になるので型エラーになるかもしれません</p>
<p>もう1つの課題は、カッコが前の文にひっつく現象です。次のコードがその例です:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kr">await</span> <span class="nx">p</span><span class="p">).</span><span class="nx">g</span><span class="p">()</span>
</span></span></code></pre></div><p>上記のコードは2つの文のつもりかもしれませんが、実際は次の1つの文として解釈されます:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">()(</span><span class="kr">await</span> <span class="nx">p</span><span class="p">).</span><span class="nx">g</span><span class="p">();</span>
</span></span></code></pre></div><p><code>f()</code> が返す関数に対して <code>(await p)</code> を引数リストとする関数呼び出しの式になってしまっています (途中にあった改行は無視)</p>
<p>この問題も、リンターによって検出可能です (ESLint に <a href="https://eslint.style/rules/js/function-call-spacing">function-call-spacing</a> というルールがある)。TypeScript ではたいてい型エラーになるでしょう</p>
<p>JavaScript のコミュニティでは、セミコロンが省略可能なケースでも書く派と、書かない派が実際両方いるようです</p>
<h2 id="goのセミコロン省略">Goのセミコロン省略</h2>
<p>Go言語はC言語風の見た目の構文を持つ言語です。
JavaScriptとは別の方法で、セミコロンを書かなくていいようになっています。
仕様書によると字句解析の段階でセミコロンを挿入するようです</p>
<ul>
<li>行末に特定の種類のトークンがあったら、その後ろにセミコロンを挿入する</li>
<li>カッコを閉じる直前のセミコロンがなくてもよいことにする</li>
</ul>
<p>(※字句解析はコンパイラの初期の処理工程。ソースコードをトークンという基本単位の列に分割すること)</p>
<p>セミコロン挿入の対象となるトークンの種類は平たくいえば「文の末尾になりうるトークン」のようです。
例えば次のコードでは <code>2</code> の直後にセミコロンが入ります</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">    <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span>   <span class="c1">// + は文の末尾にならないから挿入されない
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="mi">2</span>
</span></span></code></pre></div><p>この方法は興味深い特性があります。
上記の例のように、二項演算式の演算子は行末におくことになります (行頭に置いたら分割されてしまう)。
また、末尾カンマが実質的に必須になります</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="mi">2</span><span class="p">,</span> <span class="c1">// このカンマは必須
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span></code></pre></div><p>JavaScript でみた「カッコが前の行とくっつく」現象は発生しません</p>
<p>スタイルに若干の制約がつくものの、シンプルなルールでセミコロン省略を実現できて、意図しない挙動にもなりづらい、という印象です</p>
<p>参考: <a href="https://golang.org/ref/spec#Semicolons">#Semicolons The Go Programming Language Specification - The Go Programming Language</a></p>
<h2 id="rustのセミコロン">Rustのセミコロン</h2>
<p>Rustは比較的新しいシステムプログラミング言語です。これもC言語のような見た目の構文です。前述の JavaScript や Go と違って、セミコロン省略の仕組みを持っていません。</p>
<p>なぜその設計にしたかの公式的なドキュメントは見つかりませんでした。
ここでは経緯ではなく想像の話として、セミコロン省略の仕組みがあった場合に発生する問題について書きます</p>
<p>Rustのブロック式は、「文の並び + 最後の式(省略可)」という構造で、最後の式がそのブロックの値になるという式です。
コードの見た目として、途中の式文と最後の式の違いは「式の後ろにセミコロンがついているか」です</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rs" data-lang="rs"><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">f</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">g</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//     ^~~~~ セミコロンがない
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span></code></pre></div><p><strong>仮に</strong> Goと同様のセミコロン自動挿入があったとします。
この例では <code>g()</code> の直後にセミコロンが挿入されて式文になってしまいます。
改行をおかず同一行に <code>}</code> を置く (<code>g() }</code> とする) ことで対処可能です</p>
<p>あるいは、ブロック式の構文から「最後の式」をなくし、最後の <strong>式文</strong> の値を使う仕様も考えられます。
その場合は最後の式文が意図せず値になってしまうケースがありそうです。
最後の式文の値が使われてほしくないケースは明示的に空文を置くことで対処可能です</p>
<!-- raw HTML omitted -->
<p>参考:</p>
<ul>
<li><a href="https://users.rust-lang.org/t/why-semicolons/25074/3">Why semicolons? - community - The Rust Programming Language Forum</a> (ユーザーフォーラムのスレッド)</li>
</ul>
<h2 id="haskellのレイアウト依存構文">Haskellのレイアウト依存構文</h2>
<p>Haskellは関数型プログラミング言語の一種です。
いままで挙げた言語とは異なり、C言語の構文にまったく似てません。
C言語の視点でいえば、「文」に相当する構文要素はなく、「式」が実質的に文の役割をしています。
そして、式の並びを区切るためのセミコロンがあります</p>
<p>Haskellはレイアウトにもとづく一定の規則でセミコロンや波カッコを挿入する仕組みがあります</p>
<p>筆者はHaskellには詳しくないですが、以下の(やや古い)ページによると、次の規則でトークンが補われるそうです:</p>
<ul>
<li>一部のキーワードの直後に <code>{</code> がなかったら挿入する</li>
<li>同じ深さに字下げされている行が続いたらセミコロンを挿入する</li>
<li>字下げが浅い行が出てきたら <code>}</code> を挿入して閉じる
<ul>
<li>また、<code>}</code> によって構文エラーを回復できるときも挿入する</li>
</ul>
</li>
</ul>
<p>参考:</p>
<ul>
<li><a href="https://www.haskell.org/onlinereport/lexemes.html#sect2.7">#sect2.7 Haskell 98 Lexical Structure</a></li>
<li><a href="https://www.haskell.org/onlinereport/syntax-iso.html#layout">#layout Haskell 98 Syntax</a></li>
</ul>
<p>実際に <code>}</code> によって構文エラーが回復される例をリンク先から引用します:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hs" data-lang="hs"><span class="line"><span class="cl">    <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">e</span><span class="p">;</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">e&#39;</span>
</span></span></code></pre></div><p>レイアウトだけみるとbの右辺が <code>x in e'</code> になりますが、それだと構文エラーになってしまうため、<code>}</code> が挿入されて、</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-hs" data-lang="hs"><span class="line"><span class="cl">    <span class="kr">let</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">e</span><span class="p">;</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">}</span> <span class="kr">in</span> <span class="n">e&#39;</span>
</span></span></code></pre></div><p>となります</p>
<p>レイアウトという仕組みを使う点で、セミコロンだけでなくブロックの構造を決めるための波カッコも書かなくてよくなっていること、構文エラーを判断基準にしていることが興味深いところです</p>
<!-- raw HTML omitted -->
<h2 id="f-のリスト">F# のリスト</h2>
<p>F# は .NET の関数型言語です (C# の仲間)。
構文は OCaml という言語をベースとしていて、それに前述の Haskell のようなレイアウト依存のルールを加えたものになっています</p>
<p>F# ではリストの区切りにセミコロンを使うのも特徴的です。このセミコロンも改行によって省略可能です</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fs" data-lang="fs"><span class="line"><span class="cl">    <span class="nf">//</span>  <span class="k">xs </span><span class="nf">=</span> <span class="nf">[</span> <span class="mi">0</span><span class="k">; </span><span class="mi">1</span><span class="k">; </span><span class="mi">2</span> <span class="nf">]</span> <span class="nf">と同じ</span>
</span></span><span class="line"><span class="cl">    <span class="nf">let</span> <span class="k">xs </span><span class="nf">=</span>
</span></span><span class="line"><span class="cl">        <span class="nf">[</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">          <span class="mi">1</span>
</span></span><span class="line"><span class="cl">          <span class="mi">2</span> <span class="nf">]</span>
</span></span></code></pre></div><p>セミコロン省略の仕組みをリストの区切りにも流用できているのが興味深いところです</p>
<h4 id="内包表記と式文">内包表記と式文</h4>
<p>※追記(2025-02)：このセクションは余分だと思いますが、「文面の調整」作業を行う前の初稿に書かれているので、内容を維持するために残してあります</p>
<p>F# にはリスト内包表記の構文があります</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fs" data-lang="fs"><span class="line"><span class="cl">    <span class="nf">//</span>  <span class="k">xs </span><span class="nf">=</span> <span class="nf">[</span> <span class="mi">0</span><span class="k">; </span><span class="mi">1</span><span class="k">; </span><span class="mi">4</span><span class="k">; </span><span class="mi">9</span><span class="k">; </span><span class="mi">16</span> <span class="nf">]</span>
</span></span><span class="line"><span class="cl">    <span class="nf">let</span> <span class="k">xs </span><span class="nf">=</span> <span class="nf">[</span> <span class="nf">for</span> <span class="nf">n</span> <span class="nf">in</span> <span class="mi">0</span><span class="kt">..4</span> <span class="nf">-&gt;</span> <span class="nf">n</span> <span class="k">* </span><span class="nf">n</span> <span class="nf">]</span>
</span></span></code></pre></div><p>内包表記の中の構文は柔軟で、if式やループも使えます</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fs" data-lang="fs"><span class="line"><span class="cl">    <span class="nf">//</span>  <span class="nf">a</span> <span class="nf">=</span> <span class="nf">[</span> <span class="nf">&#34;fizz&#34;;</span> <span class="nf">&#34;1&#34;;</span> <span class="nf">&#34;2&#34;;</span> <span class="nf">&#34;fizz&#34;;</span> <span class="nf">&#34;4&#34;</span> <span class="nf">]</span>
</span></span><span class="line"><span class="cl">    <span class="nf">let</span> <span class="nf">a</span> <span class="nf">=</span>
</span></span><span class="line"><span class="cl">        <span class="nf">[</span> <span class="nf">for</span> <span class="nf">n</span> <span class="nf">in</span> <span class="mi">0</span><span class="kt">..4</span> <span class="k">do
</span></span></span><span class="line"><span class="cl"><span class="k"></span>            <span class="k">if </span><span class="nf">n</span> <span class="nf">%</span> <span class="mi">3</span> <span class="nf">=</span> <span class="mi">0</span> <span class="k">then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>                <span class="nf">&#34;fizz&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>                <span class="nf">string</span> <span class="nf">n</span> <span class="nf">]</span>
</span></span></code></pre></div><p>この <code>[]</code> の中をみると、式文を通るたびにリストに値が追加されていくというふうにみなせます。
そう考えると、普通の式の並びであるリストも式文の並びであるといえるので、同一の仕組みによって省略可能なのは自然だったかもしれません</p>
<h2 id="締め">締め</h2>
<p>C言語の構文から始めて省略する言語 (JS, Go) と省略しない言語 (Rust)、レイアウト依存の言語 (Haskell, F#) などについて書きました。
ほかにも無数の言語があります。
多様なアプローチがあっておもしろいですね</p>
<hr>
<p><strong>追記(2025-02)</strong>: 文章を全体的に調整しました</p>

        
          
            
          

          
                  <h4 class="see-also">関連記事</h4>
                  <ul>
                
                
                    <li><a href="/blog/compiler-errors/">コンパイラでのエラーの扱い</a></li>
                
                    <li><a href="/blog/2021-04-24/shared-fields-in-discriminated-unions/">判別共用体が共通フィールドを持てたら嬉しい</a></li>
                
                    <li><a href="/blog/2020-09-19/complexity-from-expression-oriented-syntax/">式指向構文が言語処理系にもたらす複雑性</a></li>
                
                    <li><a href="/blog/2020-09-18/null-pointer-vs-reference/">nullはポインタだがリファレンスではない</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://vain0x.github.io/blog/2021-02-28/diary/" data-toggle="tooltip" data-placement="top" title="近況 2021-02-28">&larr; 前ページ</a>
            </li>
          
          
            <li class="next">
              <a href="https://vain0x.github.io/blog/2021-03-29/ninja-thoughts/" data-toggle="tooltip" data-placement="top" title="ミローネ言語の開発用にビルドツールninjaを使っている感想など">次ページ &rarr;</a>
            </li>
          
        </ul>
      

      <section id="comments">
        <script
          src="https://utteranc.es/client.js"
          repo="vain0x/blog"
          issue-term="pathname"
          theme="github-light"
          crossorigin="anonymous"
          async>
        </script>
      </section>
    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:vainzerox@gmail.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/vain0x" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://qiita.com/vain0x" title="Qiita">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-qiita fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://twitter.com/vain0x" title="Twitter">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://vain0x.github.io">ベイン</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2016 - 2025
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://vain0x.github.io/blog/">ベインのブログ</a>
          

          <a href="https://github.com/vain0x/blog">[GitHub repo]</a>
        </p>
        
        <p class="credits theme-by text-muted">
          Powered by <a href="http://gohugo.io">Hugo v0.111.3</a> &nbsp;&bull;&nbsp; <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> theme based on <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>


    
  </body>
</html>

