<!DOCTYPE html>
<html lang="ja" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>式指向構文が言語処理系にもたらす複雑性 - ベインのブログ</title>
  <meta name="description" content="式指向の構文 (式の途中に文を書けるような構文) は便利な反面、言語設計の面でちょっとした課題があるという話">
  <meta name="author" content="ベイン"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "ベインのブログ",
    
    "url": "https:\/\/vain0x.github.io\/blog\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/vain0x.github.io\/blog\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/vain0x.github.io\/blog\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/vain0x.github.io\/blog\/2020-09-19\/complexity-from-expression-oriented-syntax\/",
          "name": "式指向構文が言語処理系にもたらす複雑性"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "ベイン"
  },
  "headline": "式指向構文が言語処理系にもたらす複雑性",
  "description" : "式指向の構文 (式の途中に文を書けるような構文) は便利な反面、言語設計の面でちょっとした課題があるという話\n",
  "inLanguage" : "ja",
  "wordCount":  461 ,
  "datePublished" : "2020-09-19T00:00:00",
  "dateModified" : "2020-09-19T00:00:00",
  "image" : "https:\/\/vain0x.github.io\/blog\/",
  "keywords" : [ "言語設計, Rust" ],
  "mainEntityOfPage" : "https:\/\/vain0x.github.io\/blog\/2020-09-19\/complexity-from-expression-oriented-syntax\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/vain0x.github.io\/blog\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/vain0x.github.io\/blog\/",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="式指向構文が言語処理系にもたらす複雑性" />
<meta property="og:description" content="式指向の構文 (式の途中に文を書けるような構文) は便利な反面、言語設計の面でちょっとした課題があるという話">
<meta property="og:url" content="https://vain0x.github.io/blog/2020-09-19/complexity-from-expression-oriented-syntax/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="ベインのブログ" />

  <meta name="twitter:title" content="式指向構文が言語処理系にもたらす複雑性" />
  <meta name="twitter:description" content="式指向の構文 (式の途中に文を書けるような構文) は便利な反面、言語設計の面でちょっとした課題があるという話">
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@vain0x" />
  <meta name="twitter:creator" content="@vain0x" />
  <link href='https://vain0x.github.io/favicon.jpg' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.111.3">
  <link rel="alternate" href="https://vain0x.github.io/blog/index.xml" type="application/rss+xml" title="ベインのブログ">

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  <link rel="stylesheet" href="https://vain0x.github.io/blog/css/main.css" />
  <link rel="stylesheet" href="https://vain0x.github.io/blog/css/syntax.css" />
  <link rel="stylesheet" href="https://vain0x.github.io/blog/css/codeblock.css" />

<link rel="icon" type="image/png" href="https://vain0x.github.io/favicon.jpg"/>




  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom top-nav-short">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://vain0x.github.io/blog/">ベインのブログ</a>
    </div>

    <div id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="記事一覧" href="/blog/posts">記事一覧</a>
            </li>
          
        
          
            <li>
              <a title="競プロ参戦記" href="https://qiita.com/search?q=%E7%AB%B6%E3%83%97%E3%83%AD%E5%8F%82%E6%88%A6%E8%A8%98&#43;user%3Avain0x&amp;sort=created">競プロ参戦記</a>
            </li>
          
        
          
            <li>
              <a title="ABOUT" href="https://vain0x.github.io">ABOUT</a>
            </li>
          
        
      </ul>
    </div>

    

  </div>
</nav>

    
  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>式指向構文が言語処理系にもたらす複雑性</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;2020年9月19日 投稿
  
  
  
  <span class="post-meta-tags">
  <a class="post-meta-tag" href="https://vain0x.github.io/blog/tags/%E8%A8%80%E8%AA%9E%E8%A8%AD%E8%A8%88/">言語設計</a><a class="post-meta-tag" href="https://vain0x.github.io/blog/tags/rust/">Rust</a>
  </span>
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <p><strong>式指向の構文</strong> (式の途中に文を書けるような構文) は便利な反面、言語設計の面でちょっとした課題があるという話</p>
<h3 id="式指向の構文">式指向の構文</h3>
<p>この記事ではいわゆる式指向の構文の一例として <strong>Rust風の構文</strong> を考えます</p>
<p><strong>ブロック式</strong> は次のように複数の文と1個の式からなる式です</p>
<pre tabindex="0"><code>    { 文の並び…; 式 }
</code></pre><p>文と違って、式は <strong>評価</strong> (計算) すると値が得られるものです。
ブロック式を評価する場合、文を順番に実行してから、末尾にある式を評価します。その末尾の式の値がブロック式の値となります</p>
<p>式の評価の途中で一時的に使う値をローカル変数に束縛 (代入) したりできます</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c1">// 末尾の式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></div><p>(上記は <code>let y = 式;</code> というローカル変数の宣言で、初期化式の部分にブロック式が置かれているかたち)</p>
<p>また、条件分岐を表す <code>if</code> や <code>match</code> も式です。if式では分岐の結果として評価された側のブロックの値が、そのif式の値となります</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">p</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">g</span><span class="p">()</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">try_f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></div><p>以降、サンプルコードはRust風の構文で書きます。ただし型システムや処理系はRustと同じとはかぎらず、あくまで <strong>疑似コード</strong> のスケッチと思ってください</p>
<h2 id="ジャンプとスタックマシン">ジャンプとスタックマシン</h2>
<p>式指向の構文では、式の評価の途中で <strong>ジャンプ</strong> し、その式の評価が最後まで完了しないことがあります</p>
<p>スタックマシンで計算を行おうとすると、式の途中でのジャンプには問題があります。
スタックマシンは部分式の値をスタックに積みながら式の評価を進めるので、その途中でジャンプをしてしまうと、<strong>スタックに部分式の値が残ってしまう</strong> ことになります</p>
<p>例:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>この関数をスタックマシンのコードにそのままコンパイルすると、次のような不正な振る舞いになります</p>
<ul>
<li><code>1</code> をスタックに積む</li>
<li><code>2</code> をスタックに積み、<code>return</code> する。スタックから返り値 <code>2</code> をpopして、関数から抜ける</li>
<li><del><code>3</code> をスタックに積む。スタックから2つの値をpopし、和をスタックに積む</del> (← ジャンプしたので、これは実行されない)</li>
</ul>
<p><code>1</code> をスタックに置いたまま関数を抜けてしまっているため、関数の実行の前後でスタックの状態が維持されていません</p>
<h3 id="解決策">解決策</h3>
<p>解決策はいくつかあります:</p>
<ul>
<li>式の途中でジャンプする際に、不要になる値をスタックから取り除くコードも生成する</li>
<li>式の外側にジャンプするようなコードを禁止してしまう</li>
<li>スタックマシン以外の方法を使う (レジスタマシンとか)</li>
</ul>
<h4 id="正準化-canonicalization">正準化 (canonicalization)</h4>
<p><strong>追記</strong>: 正準化(canonicalize)などの手順により、式の評価の途中でジャンプが起きないように変形しておく方法もあります (<a href="/blog/2019-04-30/diary/">近況 2019-04-30</a> にも似たような話を書きました)</p>
<p>上記のサンプルコードでいえば、次のような変形を行います</p>
<ul>
<li><code>a + b</code> → <code>{ let x = a; let y = b; x + y }</code> と変形 (一時変数の導入)</li>
<li><code>let x = { 文…; 式 };</code> → <code>文…; let x = 式;</code> と変形 (letの平坦化)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 元: 1 + { return 2; 3 }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1 + …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">   </span><span class="c1">// { return 2; … }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">  </span><span class="c1">// { …; 3 }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w">       </span><span class="c1">// _ + _
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>関数全体を文の並びに変形し、式の途中でジャンプしないようにできます (導入した一時変数がレジスタのような役割をしている)</p>
<h2 id="ジャンプする式の型">ジャンプする式の型</h2>
<p>静的型システムを備える言語を考えます</p>
<p><code>break</code>, <code>return</code> のようなジャンプ命令も構文的に式であると決めたとします (実際にRustはそう)。ジャンプ式を評価すると、ジャンプが起こって評価が中断するため、評価して得られる値というものは存在しません。このような式にどう型をつければよいでしょうか</p>
<p>例えば次の <code>match</code> 式です:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w">  </span><span class="c1">// x ← value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="p">,</span><span class="w">  </span><span class="c1">// x ← ???
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// …
</span></span></span></code></pre></div><p><code>parse(…)</code> の結果が <code>Ok(value)</code> なら、<code>match</code> の値は <code>value</code> に評価され、変数 <code>x = value</code> として後続の処理に続きます。しかし <code>parse</code> の結果が <code>Err(_)</code> なら関数から <code>return</code> します</p>
<p>Rustの場合、 <code>return</code> 式には <code>!</code> (never) という型がつきます。<code>!</code> はあらゆる型の <strong>部分型</strong> とされています。そのため <code>value</code> の型 <code>T</code> がなんであれ、<code>match</code> 式の型を <code>T</code> としてよいです</p>
<p>もうひとつの方法として、ジャンプする式の出現ごとに <strong>メタ型</strong> を割り当てる方法があります。メタ型は、型推論において未知の型を表すものです。<code>α</code> をメタ型として、<code>return</code> 式の型は <code>α</code> であるということにして、残りの型推論によって <code>α</code> の型を決定する、ということにします。上記の例では、<code>Err</code> 側にある <code>return</code> 式の型を <code>α</code> とします。<code>match</code> 式の型は「<code>T</code> または <code>α</code>」であり、<code>α = T</code> と代入すれば問題なく型がつきます</p>
<p>どちらの場合も結果は同じですが、ポイントは <strong>それを解決する何らかの仕組み</strong> が必要ということです。部分型 (<code>!</code>) を使う場合は部分型を導入する必要があり、メタ型を使う場合はメタ型を含む型推論の仕組みが必要です</p>
<p>ほかの案として、ジャンプ式に決め打ちで特定の型をつけることもできます (この方法を使う言語があるかは知りません)。その場合、上記のような <code>match</code> 式は型検査が通らないことになります。<code>return</code> を外に動かすような書き換えが必要となり、「式指向らしさ」が減ってしまいます</p>
<p>(<strong>追記</strong>: C++ にパターンマッチ機能であるinspect式を追加する提案があります。制御を返さないブランチに構文的に印をつけることで、そのブランチの評価値の型を型検査時に無視する、という方法が述べられているようです。
参考: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1371r3.pdf">Pattern Matching - p1371r3.pdf</a>)</p>
<h2 id="if式の後ろのセミコロン">if式の後ろのセミコロン</h2>
<p>C言語のような「セミコロン必須」の構文を考えます。if文の構文を単純に「文」から「式」に移動すると、従来のif文の記述が式文になることで、 <strong>一見余計なセミコロンが必要になる</strong> という問題があります</p>
<p>もともと、式文やif文の定義を次のようにしたとします (elseは省略):</p>
<pre tabindex="0"><code>    # 式文
    ExpressionStatement = Expression &#34;;&#34;

    # if文
    IfStatement = &#34;if&#34; &#34;(&#34; Expression &#34;)&#34; Block

    # 文
    Statement = ExpressionStatement | IfStatement | …

    # 式
    Expression = …
</code></pre><p>これらを式に統合したとします (ただし式文は文に残す):</p>
<pre tabindex="0"><code>    # 式文
    ExpressionStatement = Expression &#34;;&#34;

    # 文
    Statement = ExpressionStatement

    # if式
    IfStatement = &#34;if&#34; &#34;(&#34; Expression &#34;)&#34; Block

    # 式
    Expression = IfExpression | …
</code></pre><p>この構文で「普通のif文」は1個の式であることになります</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="err">…</span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>文が必要な場所にこれを書こうとすると、式文は末尾に <code>;</code> が必要なので、一見余計なセミコロンを書くことになります</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="err">…</span><span class="p">};</span><span class="w"> </span><span class="c1">// ← 式文
</span></span></span><span class="line"><span class="cl"><span class="c1">//               ^ このセミコロンが必要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">f</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></div><p>(ちなみに、構文から「文」自体をなくして、式を順番に評価するための <code>式; 式</code> という式を導入しても、セミコロンが必須なら状況は同じです)</p>
<h3 id="解決策-1">解決策</h3>
<p>ひとつの解決策は <code>if</code> キーワードで始まる文を特別扱いすることです。つまり、<code>if</code> で始まる式文だけ末尾のセミコロンをなくすという、部分的なセミコロンの省略ルールを作ります</p>
<p>ただし、if式から始まる式文のパースがうまくいかない問題があります。例えば次の文は、<code>.</code> の左辺に<code>if</code> 式がある構造になっています:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">flip</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">opponent</span><span class="w"> </span><span class="p">}.</span><span class="n">win</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//  -----------------------------------^
</span></span></span></code></pre></div><p>JavaScriptにすでに似たような問題があります。<code>function f() {}</code> という記述は関数を定義する「文」でもあり、いわゆる関数オブジェクトを表す式でもあります。構文上、前者が優先されるため、<code>function</code> キーワードで始まる式文を書くことはできません。回避策として <code>(function(){})()</code> のように式の先頭が <code>function</code> にならないようにする方法があります。この回避策はおそらくコミュニティにも受け入れられており、「文優先」の構文でも問題ないと思います</p>
<p>また、Rustは <strong>打ち切り規則</strong> と呼ばれる構文上の規則を用意しています。打ち切り規則は、おおまかにいうと「文頭にif式がある場合、それが明らかに他の式の一部でなければ、末尾のセミコロンの省略を許す」というものです。例えば次のコードは、2つの文にパースされます:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="p">{</span><span class="err">…</span><span class="p">}</span><span class="w">  </span><span class="c1">// 末尾にセミコロンなし
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">f</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><p>一方、次のコードにおいてif式は <code>.</code> の左辺となっています。このケースではセミコロンが省略されているとはみなされません</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="p">{</span><span class="err">…</span><span class="p">}.</span><span class="n">f</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//         ^ . は左辺に式が必要なので文のパースを続ける
</span></span></span></code></pre></div><p>(特別扱いされているのは <code>.</code> と <code>?</code> だけで、二項演算子は打ち切られるらしい: <code>if cond { 42 } / 2</code> など)</p>
<p>参考: <a href="https://qnighy.hatenablog.com/entry/2017/04/22/070000">Rustの文でセミコロンを省略してよい条件 - 簡潔なQ</a></p>
<p>(<strong>追記(2024-10-10)</strong>: 文章を全体的に調整しました)</p>

        
          
            
          

          
                  <h4 class="see-also">関連記事</h4>
                  <ul>
                
                
                    <li><a href="/blog/compiler-errors/">コンパイラでのエラーの扱い</a></li>
                
                    <li><a href="/blog/2021-04-24/shared-fields-in-discriminated-unions/">判別共用体が共通フィールドを持てたら嬉しい</a></li>
                
                    <li><a href="/blog/2021-03-21/semicolon-syntax/">プログラミング言語の構文とセミコロン</a></li>
                
                    <li><a href="/blog/2020-09-18/null-pointer-vs-reference/">nullはポインタだがリファレンスではない</a></li>
                
                    <li><a href="/blog/2018-11-08/pi-challenge/">円周率チャレンジにアルゴリズムでチャレンジ</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://vain0x.github.io/blog/2020-09-18/null-pointer-vs-reference/" data-toggle="tooltip" data-placement="top" title="nullはポインタだがリファレンスではない">&larr; 前ページ</a>
            </li>
          
          
            <li class="next">
              <a href="https://vain0x.github.io/blog/2020-09-30/diary/" data-toggle="tooltip" data-placement="top" title="近況 2020-09-30">次ページ &rarr;</a>
            </li>
          
        </ul>
      

      <section id="comments">
        <script
          src="https://utteranc.es/client.js"
          repo="vain0x/blog"
          issue-term="pathname"
          theme="github-light"
          crossorigin="anonymous"
          async>
        </script>
      </section>
    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:vainzerox@gmail.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/vain0x" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://qiita.com/vain0x" title="Qiita">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-qiita fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://twitter.com/vain0x" title="Twitter">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://vain0x.github.io">ベイン</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2016 - 2025
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://vain0x.github.io/blog/">ベインのブログ</a>
          

          <a href="https://github.com/vain0x/blog">[GitHub repo]</a>
        </p>
        
        <p class="credits theme-by text-muted">
          Powered by <a href="http://gohugo.io">Hugo v0.111.3</a> &nbsp;&bull;&nbsp; <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> theme based on <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>


    
  </body>
</html>

