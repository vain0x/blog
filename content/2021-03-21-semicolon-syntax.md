---
title: プログラミング言語の構文とセミコロン
type: "post"
date: 2021-03-21
url: 2021-03-21/semicolon-syntax
tags:
  - 言語設計
---

C言語などにみられる文の区切りとしてのセミコロンについて、いくつかのプログラミング言語の事例をみていく記事です

## 記事の流れ

この記事は主張や結論があるわけではなく、単に複数のトピックを書いています

- はじめにC言語の構文定義においてセミコロンが「必須」になっている部分を確認します
- 次に、セミコロンを「省略」できる構文設計の仕組みや、その影響をみていきます
- 一方、Rustにおいてセミコロンの「省略」の仕組みがなく、もしあったらどうなっていたか考えます
- 最後に (余談ですが) F# のリスト構文におけるセミコロンの見方に触れています

<!-- 余談: そもそもセミコロンがないと文の区切りは曖昧になるのかどうか?: おそらく技術上の問題はないが、パーサーにも人間にもあまり優しくないのでは -->

## C言語のセミコロンと文・宣言

C言語の構文は「文の末尾にセミコロンが必須」とよく説明されます。基本的にそのとおりですが、次の点についても説明がつくように、まずCの構文定義をみていきます

- `int a;` や `f();` のような記述ではセミコロン必須
- `while (1) {}` のようにセミコロンがなくてもいいこともある
    - 「`{}` で終わる場合はセミコロンがつかない」という誤解
- `struct S {};` のように `{}` とセミコロンの両方が出てくることもある

C言語の構文は主に **式**、**文**、**宣言** の3種類に分かれます

(※関数の本体における構文だけ取り上げます。また、ラベルや属性は本題から外れるので無視します)

### 文の末尾の記号

式についてはいうまでもないので説明は省略します。宣言は後回しにします

文から見ていきます。**文の末尾が `;` か `}` か** という観点で、文を3種類に分類します:

- 明示的にセミコロンで終わる文
- 複合文
- 文で終わる文

**明示的にセミコロンで終わる文** は文の定義として最後にセミコロンが書かれているものです。例えば式文の定義は `expression ;` (式の後ろにセミコロン) となっていて、末尾がセミコロンになります。この種の文は、ほかに break, return, do-while などがあります。これらの文は「セミコロン必須」の説明に合致します

次に **複合文** は複数の文 (や宣言) を包んで1つの文とするものです。例えば `{ f(); g(); }` という記述は、関数呼び出しの式文2つから構成される複合文です。複合文の末尾は、見ての通り `}` で終わります。複合文が存在するため「文の末尾にセミコロンがつかない」状況が発生するわけです

> 複合文の定義: `{}` の中に文や宣言を0個以上並べたものという意味
>
> ```c
>     { statement | declaration...(optional) }
> ```

最後に上記以外の文を確認します。これらは文の前方にいろいろと足していく構造とみなせます。例えば `while` 文の定義は次の通り:

```c
    while ( expression ) statement
```

この文の末尾はまた別の何らかの文ですが、「文の末尾にある文」をたどっていくと最終的には末尾が文でないものにたどり着き、それはセミコロンで終わる文か、複合文のどちらかです。そのため、文の末尾は必ず `;` か `}` で終わることとなります

```c
    // 例: 式文の手前にいろいろくっついているが、
    //     文全体としてはセミコロンで終わる

    if (p) {} else for(;;) while (r) f();
    //                               ^~~~
```

### 宣言

(※宣言の構文を深堀りすると本題から逸れるので詳しくは書きません……)

宣言は `int a;` のように変数を宣言する構文であるだけでなく、`typedef int i32;` や `struct S { int x; };` のように型を定義する構文でもあります

宣言の末尾は `;` となります。`struct S {…};` における `{}` は前述の複合文とは関係なく、型の記述の一部です。これが「`{}` とセミコロンの両方が出てくる」ケースに相当します

基本的に、宣言は `型 変数, 変数, …;` という構造です。ただし「型」や「変数」の部分は単純な型名や変数名にかぎりません。
型の部分に `struct S {…}` のような構造体の定義を記述することができます。
さらにその場合、変数の部分は省略可能なので、`型;` だけで宣言として完結します

```c
    // 型の部分が struct S {…} で、「変数…」の部分が省略された宣言
    struct S { int x; };
```

このような「型の定義」もあくまで宣言の一種であるため、変数リストの部分を書くこともできます:

```c
    // 「変数…」の部分が obj (変数名) である宣言
    struct S { int x; } obj;
```

つまり、このように `struct S {…}` の後ろにまだ変数リストが続けられるので、`}` で終わりという構文になっていないと考えられます

ちなみに型の定義を宣言の構文の一種にするという設計は、C言語に近い見た目のほかの言語でもあまり踏襲されていなさそうです (後述の JavaScript, Go, Rust など)

### 参考

- [Statements - cppreference.com](https://en.cppreference.com/w/c/language/statements)
- [Declarations - cppreference.com](https://en.cppreference.com/w/c/language/declarations)



## JavaScriptの自動セミコロン挿入

JavaScriptはC言語の構文を踏襲した言語の1つです。
構文は当時人気だったJavaに似せて作られたといわれています (C言語→Java→JavaScriptと構文の見た目に系譜がある)

JavaScriptには自動セミコロン挿入という機能があります (詳細はリンク先を参照)。
平たくいうと行末にはセミコロンを書かなくていいということです

[字句文法 - JavaScript | MDN #自動セミコロン挿入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion)

自動セミコロン挿入に関して、いくつか課題が知られています。1つ目の課題は `return` の直後に改行を入れると文が区切られるものです。
上記のリンク先にある例を引用します:

> ```js
> return
> a + b
>
> // 上記の文は、 ASI によって次のように変換されます
>
> return;
> a + b;
> ```

上の文は `return (a + b);` という1つの文のつもりで書かれているかもしれませんが、実際には `return;` と `a + b;` という2つの文に解釈されます (これは意図しない挙動かもしれない)

あくまで筆者の感覚でいえば、この問題が実際にトラブルになることは少ないと思います。
このケースでは `return;` 文の後ろにある `a + b;` の文は絶対に実行されないので、エディタの機能や、Lint (プログラムの誤りを指摘するツール) があれば、警告を受けます。TypeScript を使って型検査をしていれば、関数の返り値の型が `void` (返り値なし) になるので型エラーになるかもしれません

もう1つの課題は、カッコが前の文にひっつく現象です。次のコードがその例です:

```js
    f()
    (await p).g()
```

```js
    // 上記のコードは次の1つの文と解釈される
    f()(await p).g();
```

上の文は、`f();` と `(await p).g();` という2つの文のつもりかもしれませんが、実際には1つの文です。`f()(await p)` の部分をよくみると、`f()` という関数に、`(await p)` という引数リストを与えて関数呼び出しする式になっています。途中にあった改行は無視されます

```js
    f()(await p)
    // ^~~~~~~~~ 関数呼び出しの引数リスト
```

これも Lint ツールによって検出可能で (ESLint に [function-call-spacing](https://eslint.style/rules/js/function-call-spacing) というルールがある)、TypeScript ではたいてい型エラーになるでしょう

JavaScript のコミュニティでは、セミコロンが省略可能なケースでも書く派と、書かない派が実際両方いるようです

## Goのセミコロン省略

Go言語もC言語風の見た目の構文を持つ言語です。
JavaScriptとは別の方法で、セミコロンを書かなくていいようになっています。
仕様書によると字句解析の段階でセミコロンを挿入するようです

- 行末に特定の種類のトークンがあったら、その後ろにセミコロンを挿入する
- カッコを閉じる直前のセミコロンがなくてもよいことにする

(※字句解析はコンパイラの初期の処理工程。ソースコードをトークンという基本単位の列に分割すること)

セミコロン挿入の対象となるトークンの種類は仕様にいろいろ書かれてますが、要するに「文の末尾になりうるトークン」のようです。
例えば次のコードの1行目は `+` で終わっているのでセミコロンは挿入されず、2行目は `2` で終わっているので挿入されます

```go
    a = 1 +
        2
```

この方法は興味深い特性があります。
上の例のように、二項演算式の演算子は行末におくことになります (行頭に置いたら分割されてしまう)。
また、末尾カンマが実質的に必須になります

```go
    a := []int{
        1,
        2, // このカンマは必須、ないとセミコロンが挿入されてしまう
    }
```

JavaScript でみた「カッコが前の行とくっつく」現象は発生しません

スタイルに若干の制約がつくものの、シンプルなルールでセミコロン省略を実現できて、意図しない挙動にもなりづらい、という印象です

参考: [#Semicolons The Go Programming Language Specification - The Go Programming Language](https://golang.org/ref/spec#Semicolons)



## Haskellのレイアウト依存構文

Haskellは関数型プログラミング言語の一種です。
いままで挙げた言語とは異なり、C言語の構文にまったく似てません。
C言語の視点でいえば、「文」に相当する構文要素はなく、「式」が実質的に文の役割をしています。
そして、式の並びを区切るためのセミコロンがあります

Haskellはレイアウトにもとづく一定の規則でセミコロンや波カッコを挿入する仕組みがあります

筆者はHaskellには詳しくないですが、以下の(やや古い)ページによると、次の規則でトークンが補われるそうです:

- 一部のキーワードの直後に `{` がなかったら挿入する
- 同じ深さに字下げされている行が続いたらセミコロンを挿入する
- 字下げが浅い行が出てきたら `}` を挿入して閉じる
    - また、`}` によって構文エラーを回復できるときも挿入する

参考:

- [#sect2.7 Haskell 98 Lexical Structure](https://www.haskell.org/onlinereport/lexemes.html#sect2.7)
- [#layout Haskell 98 Syntax](https://www.haskell.org/onlinereport/syntax-iso.html#layout)

実際に `}` によって構文エラーが回復される例をリンク先から引用します:

```hs
    let x = e; y = x in e'
```

レイアウトだけみるとbの右辺が `x in e'` になりますが、それだと構文エラーになってしまうため、`}` が挿入されて、

```hs
    let { x = e; y = x } in e'
```

となります

レイアウトという仕組みを使う点で、セミコロンだけでなくブロックの構造を決めるための波カッコも書かなくてよくなっていること、構文エラーを判断基準にしていることが興味深いところです

<!-- (※PureScriptとかどうなってるんだろうか) -->



## Rustのセミコロン

Rustは比較的新しいシステムプログラミング言語です。これもC言語のような見た目の構文です。前述の JavaScript や Go と違って、セミコロン省略の仕組みを持っていません。なぜその設計にしたかの公式的なドキュメントは見つかりませんでした

<!-- ※ちゃんと探したのか……？ -->

ここではセミコロン省略の仕組みがあった場合に発生する問題について書きます

Rustのブロック式は、文の並びの最後に1個の式を置くという構造になっています。
文の並びを実行してから最後の式を評価し、その値がブロック式の値になる、というものです。
途中の式文と、最後の式の違いは、見た目としては末尾にセミコロンの有無で判断することとなります

```rs
    let x = {
        f();   // これは式文
        g()    // これはブロックの末尾の式
    //     ^----- ここをよく見るとセミコロンがない
    };

    // 全体としては let x = {…}; という変数定義で、{…} の部分が1つの式
```

上の例では、ブロック文の中に2つの関数呼び出しの式 `f()` と `g()` があります。`f();` は末尾にセミコロンがついているので単一の式文です。一方、`g()` の後ろにセミコロンがないので、これは式文ではなく、ブロックの最後の式であるということになります

仮に、Goと同様の仕組みによりセミコロンの自動挿入を行う仕様だったとして考えてみます。
この場合、前述のコードは `g()` の後ろにセミコロンが挿入されるため、ブロックに2つの文があって、最後の式がない、という状態になってしまいます

```rs
    let x = {
        f()    // これは式文
        g()    // これも式文
    };
```

(※最後の式がないブロック式の値は `()` (ユニットと読む) という特殊な値になります。これはCの `void` に相当する、関数や式に値がないことを表すものです)

最後の式を書くためには、直後に改行を入れるとまずいので、`}` を同じ行に置くことで一応対処できます。
ほかの言語とかなり見た目が異なることになります

<!-- 余談: Rustでは weirdness budget という考えかたがある。「ほかの言語と違う」ことには限度があるため、違いを生じる要素は各々予算を消費しているとみなす -->

```rs
    let x = {
        f()      // これは式文
        g() };   // これは式。改行を入れてはいけない
```

あるいは、ブロック式の構文自体を変更して、「最後の式文の値をブロック式の値とする」こともできます。
この場合、最後の式文の値を捨てるために追加の記述が必要となります

```rs
    {
        f()
        g()  // g() は何か値を返すが、それは捨てたい、という前提
        ()   // 最後の式を捨てることを明記
    }
```

また、ブロックの型が `()` だったら値を捨てるという規則も考えられますが、型推論と相性が悪いのではないかと思います

参考:

- [Why semicolons? - community - The Rust Programming Language Forum](https://users.rust-lang.org/t/why-semicolons/25074/3) (ユーザーフォーラムのスレッド)

## F\# のリスト

F# は .NET の関数型言語です (C# の仲間)。
構文はCに似ておらず、OCaml という言語の構文をベースにしています。
前述のHaskellと同様に、C言語的な意味での「文」はなく、文に相当するものは式になっています。
式の区切りを明記する場合にセミコロンを使用できます

F# ではリストの区切りにセミコロンを使うのも特徴的です。
次のコードで `xs` は 0, 1, 2 の3要素からなるリストです

```fs
    //  xs : int list 型
    let xs = [ 0; 1; 2 ]
```

ほかの言語ではリストの区切りにカンマを使うことが多いですが、F# における「カンマ区切りの式」はタプルを表します。セミコロンをカンマに置き換えると、構文的に適正ですが、意味が変わってしまいます。
次のコードの `x` は、`(0, 1, 2)` という3要素からなるタプルがあって、そのタプルだけを要素とする長さ1のリストになります

```fs
    //  x : (int * int * int) list 型
    let x = [ 0, 1, 2 ]
```

(実際こういう書き間違いかたをすると、ややこしい型エラーになりがちです)

セミコロンの話に戻すと、F# の構文では、リストの要素の区切りであるセミコロンも改行によって省略可能です。
セミコロン省略の仕組みを、文の区切りだけでなく、リストの区切りにも流用できているのが興味深いところです

```fs
    //  xs : int list 型
    let xs =
        [ 0
          1
          2 ]
```

※ちなみに `[]` がこの位置にあるのは、標準的なコードフォーマッターである [fantomas](https://github.com/fsprojects/fantomas) がこういうレイアウトにするため。`let xs = [ 改行 0; 1; 2 改行 ]` でもいい

#### 内包表記と式文

※追記(2025年2月)：このセクションは余分な気もしますが、「文面の調整」作業を行う前の初稿に書かれているので、内容を維持するために残してあります

F# にはリスト内包表記の構文があります

```fs
    //  xs = [ 0; 1; 4; 9; 16 ]
    let xs = [ for n in 0..4 -> n * n ]
```

内包表記の中の構文は柔軟で、if式やループも使えます

```fs
    //  f = [ "fizz"; "1"; "2"; "fizz"; "4" ]
    let f =
        [ for n in 0..4 do
            if n % 3 = 0 then
                "fizz"
            else
                string n ]
```

この `[]` の中をみると、式文の値がリストに追加されていくというふうにもみなせます。
それを踏まえて普通の式の並びからなるリストを見ると、これもまた式文を書き並べただけだといえます

```fs
    let xs = [ 0; 1; 2 ]
```

つまりリストの要素をブロック内の文を同等とみなせば、それらの区切りが同一の仕組みによって省略可能になることは自然だったかもしれないということです

---

**追記(2025-02)**: 文章を全体的に調整しました
