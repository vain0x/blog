---
title: "ReactとGCのアナロジー"
type: "post"
date: 2025-08-30
url: react-gc-analogy
tags:
  - React
  - エッセイ
---

ReactをGCのアナロジーで見直す。無くてもいいけど有ると便利で、リソースのライフサイクル管理を自動化する仕組みという点が共通している。一方、APIの増減や抽象化の漏れやすさに違いがある

<!--more-->

## ReactとGC

- **React**
    - UI要素のライフサイクル (作成・更新・破棄) を自動化する仕組み
- **GC** (ガベージコレクション)
    - 確保したメモリを自動で解放する仕組み

どちらもバリエーションや類似技術が少なからずあるが、この記事はそのあたりふわっとしている

## 類似している側面

- 下層を直接操作すれば同じことができる
    - React: DOM API を直接使えばいい
    - GC: メモリアロケータを直接使えばいい
- 実行時にオーバーヘッドがかかる
    - React: VDOMの生成・比較などのオーバーヘッドがかかる (メモ化によって軽減できる)
    - GC: 追跡やコピー処理などのオーバーヘッドがかかる (並行処理や世代管理によって軽減されている)
- 内部実装の複雑性が高い

## アナロジーにできない側面

### 安全性の深刻度

- React を使わない場合に発生する誤りはロジックエラーにしかならない (少なくとも言語の抽象化を破壊するわけではない。UI要素の更新漏れとかはよくある)
- GC を使わない場合に発生する誤りは深刻度が高い (脆弱性へのつながりやすさ、デバッグの困難さ)

### APIの透過性

- React: APIは純増
    - renderの純粋性、フックのルール、フックの依存リストなどの非自明な制限もある
- GC: APIはほぼ透過的 (使用者側で意識する必要はあまりない)
    - メモリを解放するAPIがなくなる
    - チューニング用のAPIはある

### 抽象化の漏れ

- React: 頻繁にエスケープハッチを要する
    - useRef, useEffect などを使う
- GC: 状況次第で、手動メモリ管理が必要になることがある (FFIなど)
    - GCが課しているルールに違反しない必要がある

## その他

GCの有無はシステムの設計にもかかわる
アリーナアロケーションとか

## 結論

- アナロジーとして成立しているような、していないような、微妙な感じ
